---
title: "track_vacation"

format:
  html:
    page-layout: full
    css: styles.css
    embed-resources: true

runtime: shiny

execute:
  echo: false
  warning: false
  message: false
  error: false

---

```{r}
#| echo: false
#| warning: false
#| message: false
#| error: false

library(shiny)
library(DT)
library(lubridate)
library(readr)
library(openxlsx)

data_file <- "vacation_data.xlsx"

# UI
ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      .centered-title {
        text-align: center;
        font-size: 40px;
        font-weight: bold;
        color: #ffffff;
        background: linear-gradient(90deg, #ff4e50, #f9d423, #24fe41, #00c6ff, #ff4e50);
        background-size: 400% 400%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: rainbow 5s ease infinite;
        margin-bottom: 30px;
      }

      @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
    "))
  ),
  
  div(class = "centered-title", "🎉 Employee Vacation Tracker 🎉"),
  
  # Continue with your layout...
  fluidRow(
    column(width = 12, style = "width: 100%;", DTOutput("vacation_table"))
  ),
  fluidRow(
    column(
      width = 12,
      DTOutput("vacation_table"),
      br(),
      
      fluidRow(
        column(3, style = "min-width: 250px;",uiOutput("employee_selector")),
        column(3, style = "min-width: 250px;",dateRangeInput("vacation_dates", "📅 Select Vacation Dates")),
        column(3, style = "min-width: 250px;",br(), actionButton("add_vacation", "➕ Add Vacation")),
        column(2, style = "min-width: 250px;",br(), downloadButton("download_csv", "Download CSV"))
      ),
      br(),
      
      fluidRow(
        column(3,  textInput("new_employee", "🆕 Add New Employee")),
        column(3,  selectInput("employee_country", "🌍 Employee Country", choices = c("India", "USA", "UK"))),
        column(1,  br(), actionButton("add_employee", "➕  Add Employee"))),
      
      br(),
    
      fluidRow(
        column(3, selectInput("holiday_country", "🌍 Select Country", choices = c("India", "USA", "UK"))),
        column(3, dateInput("manual_holiday", "📅 Add Public Holiday", value = Sys.Date())),
        column(2, br(), actionButton("add_holiday", "➕  Add Holiday"))),
      
      br(),
      
  tags$ul(
  tags$li(tags$span(style = "background-color:white; color:red; padding:2px 6px;",
          HTML("🔴 Weekend"))),
  tags$li(tags$span(style = "background-color:white; color:blue; padding:2px 6px;",
          HTML("🔵 Public Holiday"))),
  tags$li(tags$span(style = "background-color:white; color:green; padding:2px 6px;",
              HTML("✅ Vacation"))
  )))))

# Server
server <- function(input, output, session) {
  selected_year <- reactiveVal(NULL)
  initial_employees <- reactiveVal(NULL)
  employee_countries <- reactiveVal(list())
  vacation_data <- reactiveVal(NULL)
  last_vacation_date <- reactiveVal(NULL)
  dates <- reactiveVal(NULL)
  day_row <- reactiveVal(NULL)
  
  holiday_list <- reactiveValues(
    India = as.Date(c("2025-01-01")),
    UK = as.Date(c("2025-01-01")),
    USA = as.Date(c("2025-01-01"))
  )
  
  # Load saved data or show modal
  observe({
    if (file.exists(data_file)) {
      wb <- loadWorkbook(data_file)
      mat <- read.xlsx(wb, sheet = "vacation_data", rowNames = TRUE)
      initial_employees(rownames(mat))
      vacation_data(as.matrix(mat))
      
      emp_country_df <- read.xlsx(wb, sheet = "employee_countries", colNames = TRUE)
      emp_country_map <- setNames(as.list(emp_country_df$Country), emp_country_df$Employee)
      employee_countries(emp_country_map)
      
      year_val <- read.xlsx(wb, sheet = "metadata")$year[1]
      selected_year(year_val)
      
      year_dates <- seq.Date(from = as.Date(paste0(year_val, "-01-01")),
                             to = as.Date(paste0(year_val, "-12-31")),
                             by = "day")
      dates(year_dates)
      day_row(format(year_dates, "%a"))
      last_vacation_date(min(year_dates))
      
      updateDateInput(session, "manual_holiday", min = min(year_dates), max = max(year_dates))
    } 
    #show modal
    else {
      showModal(modalDialog(
        title = "Initialize Vacation Tracker",
        numericInput("year_input", "Enter Year", value = 2025, min = 2000, max = 2100),
        textInput("employee_input", "Enter Initial Employees (Format: Name:Country)", value = "Alice:UK"),
        footer = tagList(
          modalButton("Cancel"),
          actionButton("confirm_init", "Confirm")
        )
      ))
    }
  })
  
  observeEvent(input$confirm_init, {
  # Set selected year
  selected_year(input$year_input)

  # Parse employee input
  emp_entries <- strsplit(input$employee_input, ",\\s*")[[1]]
  emp_names <- c()
  emp_country_map <- list()
  for (entry in emp_entries) {
    parts <- strsplit(entry, ":")[[1]]
    if (length(parts) == 2) {
      emp_names <- c(emp_names, parts[1])
      emp_country_map[[parts[1]]] <- parts[2]
    }
  }

  # Store employee data
  initial_employees(emp_names)
  employee_countries(emp_country_map)

  # Generate date sequence for the selected year
  year_dates <- seq.Date(
    from = as.Date(paste0(input$year_input, "-01-01")),
    to = as.Date(paste0(input$year_input, "-12-31")),
    by = "day"
  )
  dates(year_dates)
  day_row(format(year_dates, "%a"))
  last_vacation_date(min(year_dates))

  # Initialize vacation matrix
  mat <- matrix("", nrow = length(emp_names), ncol = length(year_dates))
  rownames(mat) <- emp_names
  colnames(mat) <- format(year_dates, "%d-%b")

  # Update reactive vacation data
  vacation_data(mat)

  # Update date input limits
  updateDateInput(session, "manual_holiday", min = min(year_dates), max = max(year_dates))

  # Trigger UI update explicitly if needed
  output$vacation_matrix_ui <- renderTable({
    req(vacation_data())
    vacation_data()
  })

  # Save and close modal
  save_data()
  removeModal()
})

  
  employees <- reactive({
    req(initial_employees())
    initial_employees()
  })
  
  
  observeEvent(input$add_employee, {
    new_emp <- input$new_employee
    new_country <- input$employee_country
    
    # Validate input
    if (nzchar(new_emp) && !(new_emp %in% employees())) {
      
      # Update employee list
      emp_list <- c(employees(), new_emp)
      initial_employees(emp_list)
      
      # Update country mapping
      country_map <- employee_countries()
      country_map[[new_emp]] <- new_country
      employee_countries(country_map)
      
      # Add new row to vacation matrix
      mat <- vacation_data()
      new_row <- matrix("", nrow = 1, ncol = ncol(mat))
      rownames(new_row) <- new_emp
      colnames(new_row) <- colnames(mat)
      mat <- rbind(mat, new_row)
      vacation_data(mat)
      
      # Save updated data
      save_data()
      
      # Optional: Notify user
      showNotification(paste("✅ Added", new_emp, "from", new_country), type = "message")
    } else {
      showNotification("⚠️ Employee name is empty or already exists", type = "error")
    }
  })
  
  
  output$employee_selector <- renderUI({
    selectInput("employee", "🔽 Select Employee", choices = employees())
  })
  
  observeEvent(input$add_vacation, {
    start_date <- input$vacation_dates[1]
    end_date <- input$vacation_dates[2]
    
    if (is.null(start_date) || is.null(end_date)) return()
    if (end_date < start_date) {
      showNotification("End date cannot be before start date.", type = "error")
      return()
    }
    
    emp <- input$employee
    dates_seq <- seq.Date(start_date, end_date, by = "day")
    cols <- format(dates_seq, "%d-%b")
    mat <- vacation_data()
    for (col in cols) {
      if (col %in% colnames(mat)) {
        mat[emp, col] <- "✅"
      }
    }
    vacation_data(mat)
    last_vacation_date(max(end_date, last_vacation_date()))
    save_data()
  })
  
  observe({
    updateDateRangeInput(session, "vacation_dates",
                         start = Sys.Date(),
                         end = Sys.Date() + 1)
  })
  
  observeEvent(input$add_holiday, {
    req(input$holiday_country, input$manual_holiday)
    
    country <- input$holiday_country
    new_date <- input$manual_holiday
    current <- holiday_list[[country]]
    
    if (!(new_date %in% current)) {
      holiday_list[[country]] <- sort(unique(c(current, new_date)))
      save_data()
      showNotification(paste("🔵 Holiday added for", country, "on", format(new_date, "%d-%b-%Y")), type = "message")
    } else {
      showNotification("⚠️ Holiday already exists for this date", type = "warning")
    }
  })
  
  output$vacation_table <- renderDT({
    req(vacation_data(), dates(), day_row())
    
    mat <- vacation_data()
    df <- rbind(Day = day_row(), mat)
    
    weekend_flags <- weekdays(dates()) %in% c("Saturday", "Sunday")
    date_cols <- format(dates(), "%d-%b")
    
    # Apply weekend and holiday flags
    for (i in seq_along(date_cols)) {
      col <- date_cols[i]
      if (weekend_flags[i]) {
        df["Day", col] <- "🔴"
      }
      for (employee in rownames(mat)) {
        emp_country <- employee_countries()[[employee]]
        if (!is.null(emp_country) && dates()[i] %in% holiday_list[[emp_country]]) {
          df[employee, col] <- "🔵"
        }
      }
    }
    
    # ✅ Enable cell editing here
    datatable(
      df,
      editable = list(target = "cell"),
      options = list(
        scrollX = TRUE,
        pageLength = 20,
        dom = 't',
        fixedColumns = list(leftColumns = 1)
      ),
      escape = FALSE,
      rownames = TRUE,
      class = 'cell-border stripe'
    ) %>%
      formatStyle(
        columns = colnames(df)[weekend_flags],
        backgroundColor = "red",
        color = "white"
      )
  })
  
observeEvent(input$vacation_table_cell_edit, {
  info <- input$vacation_table_cell_edit
  mat <- vacation_data()

  # Adjust for the extra "Day" row at the top
  if (info$row > 1) {
    row_name <- rownames(mat)[info$row - 1]
    col_name <- colnames(mat)[info$col + 1]  # +1 because rownames are shown
    value <- trimws(info$value)

    # ✅ Only allow ✅ or blank
    if (value %in% c("✅", "")) {
      mat[row_name, col_name] <- value
      vacation_data(mat)
      save_data()
    } else {
      # Revert invalid input
      showNotification("Only ✅ or blank is allowed.", type = "error")
      proxy <- dataTableProxy("vacation_table")
      replaceData(proxy, rbind(Day = day_row(), mat), resetPaging = FALSE)
    }
  }
})

  output$download_csv <- downloadHandler(
    filename = function() {
      paste("vacation_tracker_", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      mat <- vacation_data()
      write_csv(as.data.frame(mat), file)
    }
  )
  
  save_data <- function() {
    wb <- createWorkbook()
    
    # Prepare vacation matrix with holidays and weekends
    mat <- vacation_data()
    date_cols <- format(dates(), "%d-%b")
    weekend_flags <- weekdays(dates()) %in% c("Saturday", "Sunday")
    
    for (i in seq_along(date_cols)) {
      col <- date_cols[i]
      
      # Mark weekends
      if (weekend_flags[i]) {
        for (emp in rownames(mat)) {
          if (mat[emp, col] == "") mat[emp, col] <- "🔴"
        }
      }
      
      # Mark public holidays based on employee country
      for (emp in rownames(mat)) {
        emp_country <- employee_countries()[[emp]]
        if (!is.null(emp_country) && dates()[i] %in% holiday_list[[emp_country]]) {
          if (mat[emp, col] == "") mat[emp, col] <- "🔵"
        }
      }
    }
    
    # Sheet 1: Vacation Data
    addWorksheet(wb, "vacation_data")
    writeData(wb, "vacation_data", as.data.frame(mat), rowNames = TRUE)
    
    # Sheet 2: Employee Countries
    addWorksheet(wb, "employee_countries")
    emp_country_df <- data.frame(Employee = names(employee_countries()), Country = unlist(employee_countries()))
    writeData(wb, "employee_countries", emp_country_df)
    
    # Sheet 3: Metadata
    addWorksheet(wb, "metadata")
    writeData(wb, "metadata", data.frame(year = selected_year()))
    
    # Sheet 4: Public Holidays
    addWorksheet(wb, "public_holidays")
    holiday_df <- do.call(rbind, lapply(names(holiday_list), function(country) {
      data.frame(Country = country, Date = holiday_list[[country]])
    }))
    writeData(wb, "public_holidays", holiday_df)
    
    # Sheet 5: Weekends
    addWorksheet(wb, "weekends")
    weekend_df <- data.frame(Date = dates()[weekdays(dates()) %in% c("Saturday", "Sunday")])
    writeData(wb, "weekends", weekend_df)
    
    # Save workbook
    saveWorkbook(wb, data_file, overwrite = TRUE)
  }
  
}

# Run the app
shinyApp(ui, server)
```
